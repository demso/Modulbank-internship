# BankAccounts
Проект представляет собой сервис банковских счетов, использующий сервер идентификации и базу данных **PostgreSQL**:

- **Сервис банковских счетов** (`BankAccounts.Api` ): Основной функционал управления счетами, транзакциями и выписками.
- **Сервис аутентификации** (`BankAccounts.Identity`): Сервис авторизации и аутентификации пользователей с помощью токенов **JWT**.
- **База данных**: PostgreSQL для хранения данных о счетах и банковских операциях.

Адрес банковского сервиса: http://localhost:80 \
Адрес сервиса аутентификации: http://localhost:7045 \
Hangfire Dashboard: http://localhost:80/hangfire

## Запуск сервиса
### Локальный запуск
- Запустить конфигурацию `Run API, Identity and Postgres`. Запустится банковский сервис, сервис аутентификации и контейнер Postgres, откроется окно браузера на странице сервиса.\
  <img width="257" height="71" alt="image-20250811031031442" src="https://github.com/user-attachments/assets/dbe7cbf5-7412-422d-9b5c-5fe13c313a80" />
### Docker compose 
- В проекте осуществлена контейнеризация. Есть возможность запуска проектов по отдельности в контейнерах (Docker-файлы и конфигурация запуска в VS) или с помощью docker-compose (dockercompose файл или конфигурация в VS). `Run all projects in Docker` - после запуска откроет окно браузера на странице проекта.
  
  <img width="267" height="85" alt="image-20250811031101512" src="https://github.com/user-attachments/assets/619aa318-5f6c-47f3-9a79-5d7ff5b86356" /> <img width="282" height="68" alt="image-20250811031219951" src="https://github.com/user-attachments/assets/86fce1c8-292c-4350-9829-32202133c2b4" />

- Также есть возможность запускать контейнеры вне проекта с использованием docker-compose файла, т. к. контейнеры загружены в репозиторий Docker hub. Загрузите файл docker-compose.yml из корня проекта, запустите командную строку в папке со скачанным файлом и выполните команду `docker-compose up`.

## Использование API

Для взаимодействия с API банковских счетов необходимо авторизоваться:

1.  Перейдите к Swagger UI сервиса аутентификации (http://localhost:7045).
2.  Используйте эндпоинт `/api/auth/register`, чтобы зарегистрировать нового пользователя (укажите `username` и `password`).
3.  Используйте эндпоинт `/api/auth/login`, чтобы войти (укажите `username` и `password`).
4.  Скопируйте полученный JWT-токен.
5.  Вернитесь к Swagger UI банковского сервиса (http://localhost:80).
6.  Нажмите кнопку "Authorize".
7.  Введите полученный токен.
8.  Теперь вы можете выполнять авторизованные запросы к API банковских счетов.

## Возможности банковского сервиса
- **Открытие счетов трех видов**
  - Текущий `Checking`
  - Вклад `Deposit`
  - Кредитный `Credit`
- **Совершение транзакций**
  - Пополнение счета клиента `Debit`
  - Снятие средств со счета клиента `Credit`
  - Совершение трансфера между счетами
- **Изменение счетов**
  - Закрытие счета (вместо удаления)
  - Изменение процентной ставки
- Получение информации о счетах и транзакциях клиента
- **Авторизация:** клиент не может получить доступ к сервису без авторизации. После авторизации у пользователя есть доступ только к своим счетам и транзакциям, он не может пополнять и снимать средства с не принадлежащих ему счетов, изменять чужие счета.
- Получение информации о транзакциях по счету
- Получение **выписки** за определенный период. В выписке отображается:
  - Id счета
  - Имя пользователя
  - Валюта
  - Время создания выписки
  - Список операций со счетом
  - Баланс на начало периода
  - Баланс на конец периода

## Структура проекта

- `BankAccounts.Api/`: Основной сервис банковских счетов.
  - `Features/`: Функциональные модули (Accounts, Transactions).
  - `Infrastructure/`: Конфигурация БД, репозитории, сервисы, Hangfire.
  - `Common/`: Общие классы (ошибки, валидация, маппинг, MbResult).
  - `Middleware/`: Пользовательские middleware (CustomExceptionHandlerMiddleware).
  - `Migrations/`: Миграции Entity Framework Core.
- `BankAccounts.Identity/`: Сервис аутентификации и авторизации.
  - `Identity/`: Контроллеры, конфигурация IdentityServer.
- `BankAccounts.Tests/`: Проект с unit и интеграционными тестами.
  - `Unit/`: Тесты для контроллеров, обработчиков, валидаторов, репозиториев.
  - `Integration/`: Интеграционные тесты с использованием Testcontainers.

## Unit и интеграционные тесты

`dotnet test bankaccounts.sln --logger "console;verbosity=detailed"` - команда для запуска всех тестов в решении.\
**Примечание:** Если интеграционные тесты завершаются с ошибкой `502 BadGateway`, попробуйте отключить VPN.

В проекте реализовано **14** тестов:

<img width="480" height="210" src="https://github.com/user-attachments/assets/8498b97f-8ed7-47b5-b4d3-20ef976c73bc" alt="image-20250811031640724" /> <img width="480" height="210" alt="image-20250811031653760" src="https://github.com/user-attachments/assets/da31158c-c1a8-439c-96bf-96e5c28feef3" />

**4** из них - **интеграционные**, с использованием библиотеки **Testcontainers**. В рамках интеграционных тестов реализована проверка параллельной обработки запросов. Из 50-ти параллельных запросов на перевод средств в количестве 10 руб. с одного счета на другой в данном случае было выполнено 6, в ответ на остальные клиентом был получен ответ от сервера `409 Conflict`. Целостность данных и суммарный баланс **сохранены**:

<img width="401" height="138" alt="image-20250811032347709" src="https://github.com/user-attachments/assets/9a64428b-2819-47b2-93ce-2eafb9bfb4c4" />

## Хранение и обработка данных, PostgreSQL

### Индексы и оптимизация

Для повышения производительности в базе данных используются индексы:

- Хэш-индекс по `OwnerId` в таблице `Accounts`.
- B-Tree индекс по `(AccountId, DateTime)` в таблице `Transactions`.
- GiST индекс по `DateTime` в таблице `Transactions` для оптимизации диапазонных запросов.

Сервис банковских счетов использует для хранения базу данных PostgreSQL. Для эффективного поиска и фильтрации в таблице `Transctions` реализован составной индекс по столбцам `AccountId` и `DateTime`. Индекс используется при работе сервиса, например, при получении данных о транзакциях по счету за определенный период. После обработки такого запроса в консоли контейнера PostgreSQL можно увидеть его код:  

<img width="1757" height="176" alt="image-20250811040807228" src="https://github.com/user-attachments/assets/900380fc-0353-440d-a72b-2faf9f05b206" />

Анализ с помощью `EXPLAIN ANALYZE` подтверждает полезность индекса:

<img width="841" height="291" alt="image-20250811040901996" src="https://github.com/user-attachments/assets/6ce2d5fe-10c7-4acf-a1b6-4695b0dfbe8b" />

<img width="650" height="380" alt="image-20250811033850972" src="https://github.com/user-attachments/assets/dde606d7-8e14-40bf-a4ea-8f7de58fb937" />

### Хранимая процедура

Для начисления процентов по счетам реализована хранимая процедура `accrue_interest`. Данная процедура выполняется ежедневно, за ее своевременное выполнение отвечает фоновая задача библиотеки **Hangfire**. С помощью Hangfire создается повторяющаяся ежедневно задача, которая вызывает хранимую процедуру в базе данных. 

Начисление процентов выполняется в рамках общей транзакции, то есть в случае ошибки при начислении процентов на один счет, проценты не будут зачислены ни на один. Код задачи находится в файле `BankAccounts.Api\Infrastructure\Hangfire\Jobs\AccrueInterestJob.cs`, регистрация задачи производится с помощью класса `JobsRegistrator`. 

Работу задачи можно отследить по ссылке http://localhost:80/hangfire

![Hangfire recurring job](https://github.com/user-attachments/assets/64ad6b65-9846-407d-833e-d2979b304065)

### Перевод денежных средств

Для реализации потокобезопасного поведения при проведении банковских переводов между счетами в базе данных осуществлена **оптимистичная блокировка** с использованием системного поля `xmin`. Такая блокировка исключает одновременное редактирование записей из разных потоков. В классе `PerformTransferHandler` при работе с базой данных используется встроенный в **Entity Framework** механизм транзакций, который в случае ошибки конкурентного доступа отменяет произведенные изменения.

## Технологии и особенности

- **Язык:** C# 13 (.NET 9)
- **Архитектура:** Vertical Slice Architecture, CQRS, MediatR
- **База данных:** PostgreSQL (EF Core, миграции, индексы, хранимая процедура) в контейнере Docker
- **Аутентификация/Авторизация:** JWT (самописный сервис на базе IdentityServer4)
- **Контейнеризация:** Docker, Docker Compose
- **Документация API:** Swagger/OpenAPI (Swashbuckle)
- **Фоновые задачи:** Hangfire
- **Тестирование:** xUnit, Moq, Testcontainers (интеграционные тесты с реальной БД)
- **Валидация:** FluentValidation
- **Обработка ошибок:** Custom Middleware

### Особенности проекта

- Использование единого типа `MbResult` для ответов сервиса с возможностью возврата сообщения об ошибке или результата запроса.
- Транзакции и "оптимистичная блокировка" при переводе денежных средств между счетами, в случае конфликта возвращается код `409 Conflict`.
- Хранимая процедура для начисления процентов, выполняемая ежедневно.
- Использование набора индексов для ускорения и оптимизации работы с данными

